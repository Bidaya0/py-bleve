"""
Package bleve is a library for indexing and searching text.

Example Opening New Index, Indexing Data

	message := struct{
	    Id:   "example"
	    From: "marty.schoch@gmail.com",
	    Body: "bleve indexing is easy",
	}

	mapping := bleve.NewIndexMapping()
	index, _ := bleve.New("example.bleve", mapping)
	index.Index(message.Id, message)

Example Opening Existing Index, Searching Data

	index, _ := bleve.Open("example.bleve")
	query := bleve.NewQueryStringQuery("bleve")
	searchRequest := bleve.NewSearchRequest(query)
	searchResult, _ := index.Search(searchRequest)

"""
# python wrapper for package github.com/blevesearch/bleve/v2 within overall package bleve
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build --output=../py_bleve -vm=python3 .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _bleve
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from bleve import bleve
# and then refer to everything using bleve. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []*document.CompositeField
class Slice_Ptr_document_CompositeField(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Ptr_document_CompositeField_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_document_CompositeField.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Ptr_document_CompositeField len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Ptr_document_CompositeField([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Ptr_document_CompositeField_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Ptr_document_CompositeField_len(self.handle)
				return Slice_Ptr_document_CompositeField(handle=_bleve.Slice_Ptr_document_CompositeField_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_document_CompositeField(handle=_bleve.Slice_Ptr_document_CompositeField_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Ptr_document_CompositeField_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_document_CompositeField.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Ptr_document_CompositeField_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Ptr_document_CompositeField_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*mapping.FieldMapping
class Slice_Ptr_mapping_FieldMapping(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Ptr_mapping_FieldMapping_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_mapping_FieldMapping.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Ptr_mapping_FieldMapping len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Ptr_mapping_FieldMapping([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Ptr_mapping_FieldMapping_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Ptr_mapping_FieldMapping_len(self.handle)
				return Slice_Ptr_mapping_FieldMapping(handle=_bleve.Slice_Ptr_mapping_FieldMapping_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_mapping_FieldMapping(handle=_bleve.Slice_Ptr_mapping_FieldMapping_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Ptr_mapping_FieldMapping_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_mapping_FieldMapping.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Ptr_mapping_FieldMapping_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Ptr_mapping_FieldMapping_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*search.Explanation
class Slice_Ptr_search_Explanation(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Ptr_search_Explanation_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_search_Explanation.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Ptr_search_Explanation len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Ptr_search_Explanation([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Ptr_search_Explanation_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Ptr_search_Explanation_len(self.handle)
				return Slice_Ptr_search_Explanation(handle=_bleve.Slice_Ptr_search_Explanation_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_search_Explanation(handle=_bleve.Slice_Ptr_search_Explanation_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Ptr_search_Explanation_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_search_Explanation.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Ptr_search_Explanation_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Ptr_search_Explanation_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*search.TermFacet
class Slice_Ptr_search_TermFacet(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Ptr_search_TermFacet_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_search_TermFacet.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Ptr_search_TermFacet len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Ptr_search_TermFacet([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Ptr_search_TermFacet_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Ptr_search_TermFacet_len(self.handle)
				return Slice_Ptr_search_TermFacet(handle=_bleve.Slice_Ptr_search_TermFacet_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_search_TermFacet(handle=_bleve.Slice_Ptr_search_TermFacet_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Ptr_search_TermFacet_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_search_TermFacet.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Ptr_search_TermFacet_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Ptr_search_TermFacet_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*index.TokenLocation
class Slice_Ptr_index_TokenLocation(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Ptr_index_TokenLocation_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_index_TokenLocation.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Ptr_index_TokenLocation len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Ptr_index_TokenLocation([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Ptr_index_TokenLocation_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Ptr_index_TokenLocation_len(self.handle)
				return Slice_Ptr_index_TokenLocation(handle=_bleve.Slice_Ptr_index_TokenLocation_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_index_TokenLocation(handle=_bleve.Slice_Ptr_index_TokenLocation_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Ptr_index_TokenLocation_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_index_TokenLocation.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Ptr_index_TokenLocation_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Ptr_index_TokenLocation_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][][][][]float64
class Slice_Slice_Slice_Slice_Slice_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Slice_Slice_Slice_Slice_float64_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_Slice_Slice_Slice_float64.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Slice_Slice_Slice_Slice_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Slice_Slice_Slice_Slice_float64([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Slice_Slice_Slice_Slice_float64_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Slice_Slice_Slice_Slice_float64_len(self.handle)
				return Slice_Slice_Slice_Slice_Slice_float64(handle=_bleve.Slice_Slice_Slice_Slice_Slice_float64_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Slice_Slice_Slice_Slice_float64(handle=_bleve.Slice_Slice_Slice_Slice_Slice_float64_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Slice_Slice_Slice_Slice_float64_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_Slice_Slice_Slice_float64.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Slice_Slice_Slice_Slice_float64_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Slice_Slice_Slice_Slice_float64_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][][][]float64
class Slice_Slice_Slice_Slice_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Slice_Slice_Slice_float64_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_Slice_Slice_float64.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Slice_Slice_Slice_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Slice_Slice_Slice_float64([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Slice_Slice_Slice_float64_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Slice_Slice_Slice_float64_len(self.handle)
				return Slice_Slice_Slice_Slice_float64(handle=_bleve.Slice_Slice_Slice_Slice_float64_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Slice_Slice_Slice_float64(handle=_bleve.Slice_Slice_Slice_Slice_float64_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Slice_Slice_Slice_float64_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_Slice_Slice_float64.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Slice_Slice_Slice_float64_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Slice_Slice_Slice_float64_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][][]float64
class Slice_Slice_Slice_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Slice_Slice_float64_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_Slice_float64.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Slice_Slice_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Slice_Slice_float64([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Slice_Slice_float64_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Slice_Slice_float64_len(self.handle)
				return Slice_Slice_Slice_float64(handle=_bleve.Slice_Slice_Slice_float64_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Slice_Slice_float64(handle=_bleve.Slice_Slice_Slice_float64_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Slice_Slice_float64_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_Slice_float64.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Slice_Slice_float64_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Slice_Slice_float64_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]float64
class Slice_Slice_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_Slice_float64_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_float64.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_Slice_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_Slice_float64([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_Slice_float64_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_Slice_float64_len(self.handle)
				return Slice_Slice_float64(handle=_bleve.Slice_Slice_float64_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_float64(handle=_bleve.Slice_Slice_float64_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_Slice_float64_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_float64.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_Slice_float64_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_Slice_float64_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []any
class Slice_any(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_any_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_any.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_any len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_any([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_any_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_any_len(self.handle)
				return Slice_any(handle=_bleve.Slice_any_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return any(handle=_bleve.Slice_any_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_any_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_any.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_any_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_any_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []bleve.Index
class Slice_bleve_Index(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_bleve_Index_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_bleve_Index.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_bleve_Index len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_bleve_Index([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_bleve_Index_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_bleve_Index_len(self.handle)
				return Slice_bleve_Index(handle=_bleve.Slice_bleve_Index_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Index(handle=_bleve.Slice_bleve_Index_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_bleve_Index_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_bleve_Index.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_bleve_Index_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_bleve_Index_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []document.Field
class Slice_document_Field(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_document_Field_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_document_Field.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_document_Field len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_document_Field([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_document_Field_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_document_Field_len(self.handle)
				return Slice_document_Field(handle=_bleve.Slice_document_Field_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.document_Field(handle=_bleve.Slice_document_Field_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_document_Field_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_document_Field.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_document_Field_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_document_Field_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []search.FieldTermLocation
class Slice_search_FieldTermLocation(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_search_FieldTermLocation_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_search_FieldTermLocation.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_search_FieldTermLocation len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_search_FieldTermLocation([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_search_FieldTermLocation_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_search_FieldTermLocation_len(self.handle)
				return Slice_search_FieldTermLocation(handle=_bleve.Slice_search_FieldTermLocation_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.search_FieldTermLocation(handle=_bleve.Slice_search_FieldTermLocation_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_search_FieldTermLocation_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_search_FieldTermLocation.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_search_FieldTermLocation_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_search_FieldTermLocation_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []search.Location
class Slice_search_Location(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_search_Location_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_search_Location.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_search_Location len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_search_Location([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_search_Location_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_search_Location_len(self.handle)
				return Slice_search_Location(handle=_bleve.Slice_search_Location_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.search_Location(handle=_bleve.Slice_search_Location_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_search_Location_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_search_Location.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_search_Location_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_search_Location_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []query.Query
class Slice_query_Query(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Slice_query_Query_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_query_Query.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Slice_query_Query len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'bleve.Slice_query_Query([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bleve.Slice_query_Query_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bleve.Slice_query_Query_len(self.handle)
				return Slice_query_Query(handle=_bleve.Slice_query_Query_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.query_Query(handle=_bleve.Slice_query_Query_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bleve.Slice_query_Query_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_query_Query.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _bleve.Slice_query_Query_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bleve.Slice_query_Query_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]*mapping.DocumentMapping
class Map_string_Ptr_mapping_DocumentMapping(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Map_string_Ptr_mapping_DocumentMapping_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_mapping_DocumentMapping.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bleve.Map_string_Ptr_mapping_DocumentMapping_set(self.handle, k, v)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Map_string_Ptr_mapping_DocumentMapping len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bleve.Map_string_Ptr_mapping_DocumentMapping({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bleve.Map_string_Ptr_mapping_DocumentMapping_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_mapping_DocumentMapping(handle=_bleve.Map_string_Ptr_mapping_DocumentMapping_elem(self.handle, key))
	def __setitem__(self, key, value):
		_bleve.Map_string_Ptr_mapping_DocumentMapping_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _bleve.Map_string_Ptr_mapping_DocumentMapping_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_bleve.Map_string_Ptr_mapping_DocumentMapping_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bleve.Map_string_Ptr_mapping_DocumentMapping_contains(self.handle, key)

# Python type for map map[string]interface{}
class Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.Map_string_interface__CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_interface_.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bleve.Map_string_interface__set(self.handle, k, v)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bleve.Map_string_interface_({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bleve.Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		return _bleve.Map_string_interface__elem(self.handle, key)
	def __setitem__(self, key, value):
		_bleve.Map_string_interface__set(self.handle, key, value)
	def __delitem__(self, key):
		return _bleve.Map_string_interface__delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_bleve.Map_string_interface__keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bleve.Map_string_interface__contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---
from enum import Enum

class Error(Enum):
	"""
	Error represents a more strongly typed bleve error for detecting
	and handling specific types of errors.
	
	"""
	ErrorIndexPathExists = 0
	ErrorIndexPathDoesNotExist = 1
	ErrorIndexMetaMissing = 2
	ErrorIndexMetaCorrupt = 3
	ErrorIndexClosed = 4
	ErrorAliasMulti = 5
	ErrorAliasEmpty = 6
	ErrorUnknownIndexType = 7
	ErrorEmptyID = 8
	ErrorIndexReadInconsistency = 9

ErrorIndexPathExists = 0
ErrorIndexPathDoesNotExist = 1
ErrorIndexMetaMissing = 2
ErrorIndexMetaCorrupt = 3
ErrorIndexClosed = 4
ErrorAliasMulti = 5
ErrorAliasEmpty = 6
ErrorUnknownIndexType = 7
ErrorEmptyID = 8
ErrorIndexReadInconsistency = 9



#---- Constants from Go: Python can only ask that you please don't change these! ---
SearchQueryEndCallbackKey = "_search_query_end_callback_key"
SearchQueryStartCallbackKey = "_search_query_start_callback_key"


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface bleve.Builder
class Builder(go.GoClass):
	"""Builder is a limited interface, used to build indexes in an offline mode.\nItems cannot be updated or deleted, and the caller MUST ensure a document is\nindexed only once.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = 0
	def Close(self):
		"""Close() str"""
		return _bleve.bleve_Builder_Close(self.handle)
	def Index(self, id, data):
		"""Index(str id, str data) str"""
		return _bleve.bleve_Builder_Index(self.handle, id, data)

# Python type for interface bleve.Index
class Index(go.GoClass):
	"""An Index implements all the indexing and searching\ncapabilities of bleve.  An Index can be created\nusing the New() and Open() methods.\n\nIndex() takes an input value, deduces a DocumentMapping for its type,\nassigns string paths to its fields or values then applies field mappings on\nthem.\n\nThe DocumentMapping used to index a value is deduced by the following rules:\n 1. If value implements mapping.bleveClassifier interface, resolve the mapping\n    from BleveType().\n 2. If value implements mapping.Classifier interface, resolve the mapping\n    from Type().\n 3. If value has a string field or value at IndexMapping.TypeField.\n\n(defaulting to \"_type\"), use it to resolve the mapping. Fields addressing\nis described below.\n4) If IndexMapping.DefaultType is registered, return it.\n5) Return IndexMapping.DefaultMapping.\n\nEach field or nested field of the value is identified by a string path, then\nmapped to one or several FieldMappings which extract the result for analysis.\n\nStruct values fields are identified by their \"json:\" tag, or by their name.\nNested fields are identified by prefixing with their parent identifier,\nseparated by a dot.\n\nMap values entries are identified by their string key. Entries not indexed\nby strings are ignored. Entry values are identified recursively like struct\nfields.\n\nSlice and array values are identified by their field name. Their elements\nare processed sequentially with the same FieldMapping.\n\nString, float64 and time.Time values are identified by their field name.\nOther types are ignored.\n\nEach value identifier is decomposed in its parts and recursively address\nSubDocumentMappings in the tree starting at the root DocumentMapping.  If a\nmapping is found, all its FieldMappings are applied to the value. If no\nmapping is found and the root DocumentMapping is dynamic, default mappings\nare used based on value type and IndexMapping default configurations.\n\nFinally, mapped values are analyzed, indexed or stored. See\nFieldMapping.Analyzer to know how an analyzer is resolved for a given field.\n\nExamples:\n\n\ttype Date struct {\n\t  Day string `json:\"day\"`\n\t  Month string\n\t  Year string\n\t}\n\n\ttype Person struct {\n\t  FirstName string `json:\"first_name\"`\n\t  LastName string\n\t  BirthDate Date `json:\"birth_date\"`\n\t}\n\nA Person value FirstName is mapped by the SubDocumentMapping at\n\"first_name\". Its LastName is mapped by the one at \"LastName\". The day of\nBirthDate is mapped to the SubDocumentMapping \"day\" of the root\nSubDocumentMapping \"birth_date\". It will appear as the \"birth_date.day\"\nfield in the index. The month is mapped to \"birth_date.Month\".\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = 0
	def Advanced(self):
		"""Advanced() object, str"""
		return go.index_Index(handle=_bleve.bleve_Index_Advanced(self.handle))
	def Batch(self, b):
		"""Batch(object b) str"""
		return _bleve.bleve_Index_Batch(self.handle, b.handle)
	def Close(self):
		"""Close() str"""
		return _bleve.bleve_Index_Close(self.handle)
	def Delete(self, id):
		"""Delete(str id) str"""
		return _bleve.bleve_Index_Delete(self.handle, id)
	def DeleteInternal(self, key):
		"""DeleteInternal([]int key) str"""
		return _bleve.bleve_Index_DeleteInternal(self.handle, key.handle)
	def DocCount(self):
		"""DocCount() long, str"""
		return _bleve.bleve_Index_DocCount(self.handle)
	def Document(self, id):
		"""Document(str id) object, str"""
		return go.index_Document(handle=_bleve.bleve_Index_Document(self.handle, id))
	def FieldDict(self, field):
		"""FieldDict(str field) object, str"""
		return go.index_FieldDict(handle=_bleve.bleve_Index_FieldDict(self.handle, field))
	def FieldDictPrefix(self, field, termPrefix):
		"""FieldDictPrefix(str field, []int termPrefix) object, str"""
		return go.index_FieldDict(handle=_bleve.bleve_Index_FieldDictPrefix(self.handle, field, termPrefix.handle))
	def FieldDictRange(self, field, startTerm, endTerm):
		"""FieldDictRange(str field, []int startTerm, []int endTerm) object, str"""
		return go.index_FieldDict(handle=_bleve.bleve_Index_FieldDictRange(self.handle, field, startTerm.handle, endTerm.handle))
	def Fields(self):
		"""Fields() []str, str"""
		return go.Slice_string(handle=_bleve.bleve_Index_Fields(self.handle))
	def GetInternal(self, key):
		"""GetInternal([]int key) []int, str"""
		return go.Slice_byte(handle=_bleve.bleve_Index_GetInternal(self.handle, key.handle))
	def Index(self, id, data):
		"""Index(str id, str data) str"""
		return _bleve.bleve_Index_Index(self.handle, id, data)
	def Mapping(self):
		"""Mapping() object"""
		return go.mapping_IndexMapping(handle=_bleve.bleve_Index_Mapping(self.handle))
	def Name(self):
		"""Name() str"""
		return _bleve.bleve_Index_Name(self.handle)
	def NewBatch(self):
		"""NewBatch() object"""
		return Batch(handle=_bleve.bleve_Index_NewBatch(self.handle))
	def Search(self, req):
		"""Search(object req) object, str"""
		return SearchResult(handle=_bleve.bleve_Index_Search(self.handle, req.handle))
	def SearchInContext(self, ctx, req):
		"""SearchInContext(object ctx, object req) object, str"""
		return SearchResult(handle=_bleve.bleve_Index_SearchInContext(self.handle, ctx.handle, req.handle))
	def SetInternal(self, key, val):
		"""SetInternal([]int key, []int val) str"""
		return _bleve.bleve_Index_SetInternal(self.handle, key.handle, val.handle)
	def SetName(self, arg_0, goRun=False):
		"""SetName(str) """
		_bleve.bleve_Index_SetName(self.handle, arg_0, goRun)
	def Stats(self):
		"""Stats() object"""
		return IndexStat(handle=_bleve.bleve_Index_Stats(self.handle))
	def StatsMap(self):
		"""StatsMap() object"""
		return Map_string_interface_(handle=_bleve.bleve_Index_StatsMap(self.handle))

# Python type for interface bleve.IndexAlias
class IndexAlias(go.GoClass):
	"""An IndexAlias is a wrapper around one or more\nIndex objects.  It has two distinct modes of\noperation.\n1.  When it points to a single index, ALL index\noperations are valid and will be passed through\nto the underlying index.\n2.  When it points to more than one index, the only\nvalid operation is Search.  In this case the\nsearch will be performed across all the\nunderlying indexes and the results merged.\nCalls to Add/Remove/Swap the underlying indexes\nare atomic, so you can safely change the\nunderlying Index objects while other components\nare performing operations.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = 0
	def Add(self, goRun=False, *args):
		"""Add([]object i) """
		i = Slice_bleve_Index(args)
		_bleve.bleve_IndexAlias_Add(self.handle, i.handle, goRun)
	def Advanced(self):
		"""Advanced() object, str"""
		return go.index_Index(handle=_bleve.bleve_IndexAlias_Advanced(self.handle))
	def Batch(self, b):
		"""Batch(object b) str"""
		return _bleve.bleve_IndexAlias_Batch(self.handle, b.handle)
	def Close(self):
		"""Close() str"""
		return _bleve.bleve_IndexAlias_Close(self.handle)
	def Delete(self, id):
		"""Delete(str id) str"""
		return _bleve.bleve_IndexAlias_Delete(self.handle, id)
	def DeleteInternal(self, key):
		"""DeleteInternal([]int key) str"""
		return _bleve.bleve_IndexAlias_DeleteInternal(self.handle, key.handle)
	def DocCount(self):
		"""DocCount() long, str"""
		return _bleve.bleve_IndexAlias_DocCount(self.handle)
	def Document(self, id):
		"""Document(str id) object, str"""
		return go.index_Document(handle=_bleve.bleve_IndexAlias_Document(self.handle, id))
	def FieldDict(self, field):
		"""FieldDict(str field) object, str"""
		return go.index_FieldDict(handle=_bleve.bleve_IndexAlias_FieldDict(self.handle, field))
	def FieldDictPrefix(self, field, termPrefix):
		"""FieldDictPrefix(str field, []int termPrefix) object, str"""
		return go.index_FieldDict(handle=_bleve.bleve_IndexAlias_FieldDictPrefix(self.handle, field, termPrefix.handle))
	def FieldDictRange(self, field, startTerm, endTerm):
		"""FieldDictRange(str field, []int startTerm, []int endTerm) object, str"""
		return go.index_FieldDict(handle=_bleve.bleve_IndexAlias_FieldDictRange(self.handle, field, startTerm.handle, endTerm.handle))
	def Fields(self):
		"""Fields() []str, str"""
		return go.Slice_string(handle=_bleve.bleve_IndexAlias_Fields(self.handle))
	def GetInternal(self, key):
		"""GetInternal([]int key) []int, str"""
		return go.Slice_byte(handle=_bleve.bleve_IndexAlias_GetInternal(self.handle, key.handle))
	def Index(self, id, data):
		"""Index(str id, str data) str"""
		return _bleve.bleve_IndexAlias_Index(self.handle, id, data)
	def Mapping(self):
		"""Mapping() object"""
		return go.mapping_IndexMapping(handle=_bleve.bleve_IndexAlias_Mapping(self.handle))
	def Name(self):
		"""Name() str"""
		return _bleve.bleve_IndexAlias_Name(self.handle)
	def NewBatch(self):
		"""NewBatch() object"""
		return Batch(handle=_bleve.bleve_IndexAlias_NewBatch(self.handle))
	def Remove(self, goRun=False, *args):
		"""Remove([]object i) """
		i = Slice_bleve_Index(args)
		_bleve.bleve_IndexAlias_Remove(self.handle, i.handle, goRun)
	def Search(self, req):
		"""Search(object req) object, str"""
		return SearchResult(handle=_bleve.bleve_IndexAlias_Search(self.handle, req.handle))
	def SearchInContext(self, ctx, req):
		"""SearchInContext(object ctx, object req) object, str"""
		return SearchResult(handle=_bleve.bleve_IndexAlias_SearchInContext(self.handle, ctx.handle, req.handle))
	def SetInternal(self, key, val):
		"""SetInternal([]int key, []int val) str"""
		return _bleve.bleve_IndexAlias_SetInternal(self.handle, key.handle, val.handle)
	def SetName(self, arg_0, goRun=False):
		"""SetName(str) """
		_bleve.bleve_IndexAlias_SetName(self.handle, arg_0, goRun)
	def Stats(self):
		"""Stats() object"""
		return IndexStat(handle=_bleve.bleve_IndexAlias_Stats(self.handle))
	def StatsMap(self):
		"""StatsMap() object"""
		return Map_string_interface_(handle=_bleve.bleve_IndexAlias_StatsMap(self.handle))
	def Swap(self, myin, out, goRun=False):
		"""Swap([]object in, []object out) """
		_bleve.bleve_IndexAlias_Swap(self.handle, myin.handle, out.handle, goRun)

# Python type for interface bleve.IndexCopyable
class IndexCopyable(go.GoClass):
	"""IndexCopyable is an index which supports an online copy operation\nof the index.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = 0
	def CopyTo(self, d):
		"""CopyTo(object d) str"""
		return _bleve.bleve_IndexCopyable_CopyTo(self.handle, d.handle)


# ---- Structs ---

# Python type for struct bleve.SearchRequest
class SearchRequest(go.GoClass):
	"""A SearchRequest describes all the parameters\nneeded to search the index.\nQuery is required.\nSize/From describe how much and which part of the\nresult set to return.\nHighlight describes optional search result\nhighlighting.\nFields describes a list of field values which\nshould be retrieved for result documents, provided they\nwere stored while indexing.\nFacets describe the set of facets to be computed.\nExplain triggers inclusion of additional search\nresult score explanations.\nSort describes the desired order for the results to be returned.\nScore controls the kind of scoring performed\nSearchAfter supports deep paging by providing a minimum sort key\nSearchBefore supports deep paging by providing a maximum sort key\nsortFunc specifies the sort implementation to use for sorting results.\n\nA special field named \"*\" can be used to return all fields.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_SearchRequest_CTor()
			_bleve.IncRef(self.handle)
			if  0 < len(args):
				self.Query = args[0]
			if "Query" in kwargs:
				self.Query = kwargs["Query"]
			if  1 < len(args):
				self.Size = args[1]
			if "Size" in kwargs:
				self.Size = kwargs["Size"]
			if  2 < len(args):
				self.From = args[2]
			if "From" in kwargs:
				self.From = kwargs["From"]
			if  3 < len(args):
				self.Highlight = args[3]
			if "Highlight" in kwargs:
				self.Highlight = kwargs["Highlight"]
			if  4 < len(args):
				self.Fields = args[4]
			if "Fields" in kwargs:
				self.Fields = kwargs["Fields"]
			if  5 < len(args):
				self.Facets = args[5]
			if "Facets" in kwargs:
				self.Facets = kwargs["Facets"]
			if  6 < len(args):
				self.Explain = args[6]
			if "Explain" in kwargs:
				self.Explain = kwargs["Explain"]
			if  7 < len(args):
				self.Sort = args[7]
			if "Sort" in kwargs:
				self.Sort = kwargs["Sort"]
			if  8 < len(args):
				self.IncludeLocations = args[8]
			if "IncludeLocations" in kwargs:
				self.IncludeLocations = kwargs["IncludeLocations"]
			if  9 < len(args):
				self.Score = args[9]
			if "Score" in kwargs:
				self.Score = kwargs["Score"]
			if  10 < len(args):
				self.SearchAfter = args[10]
			if "SearchAfter" in kwargs:
				self.SearchAfter = kwargs["SearchAfter"]
			if  11 < len(args):
				self.SearchBefore = args[11]
			if "SearchBefore" in kwargs:
				self.SearchBefore = kwargs["SearchBefore"]
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.SearchRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.SearchRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Query(self):
		return go.query_Query(handle=_bleve.bleve_SearchRequest_Query_Get(self.handle))
	@Query.setter
	def Query(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_Query_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Size(self):
		return _bleve.bleve_SearchRequest_Size_Get(self.handle)
	@Size.setter
	def Size(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_Size_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchRequest_Size_Set(self.handle, value)
	@property
	def From(self):
		return _bleve.bleve_SearchRequest_From_Get(self.handle)
	@From.setter
	def From(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_From_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchRequest_From_Set(self.handle, value)
	@property
	def Highlight(self):
		return HighlightRequest(handle=_bleve.bleve_SearchRequest_Highlight_Get(self.handle))
	@Highlight.setter
	def Highlight(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_Highlight_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Fields(self):
		return go.Slice_string(handle=_bleve.bleve_SearchRequest_Fields_Get(self.handle))
	@Fields.setter
	def Fields(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_Fields_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Facets(self):
		return FacetsRequest(handle=_bleve.bleve_SearchRequest_Facets_Get(self.handle))
	@Facets.setter
	def Facets(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_Facets_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Explain(self):
		return _bleve.bleve_SearchRequest_Explain_Get(self.handle)
	@Explain.setter
	def Explain(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_Explain_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchRequest_Explain_Set(self.handle, value)
	@property
	def Sort(self):
		return go.search_SortOrder(handle=_bleve.bleve_SearchRequest_Sort_Get(self.handle))
	@Sort.setter
	def Sort(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_Sort_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IncludeLocations(self):
		return _bleve.bleve_SearchRequest_IncludeLocations_Get(self.handle)
	@IncludeLocations.setter
	def IncludeLocations(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_IncludeLocations_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchRequest_IncludeLocations_Set(self.handle, value)
	@property
	def Score(self):
		return _bleve.bleve_SearchRequest_Score_Get(self.handle)
	@Score.setter
	def Score(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_Score_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchRequest_Score_Set(self.handle, value)
	@property
	def SearchAfter(self):
		return go.Slice_string(handle=_bleve.bleve_SearchRequest_SearchAfter_Get(self.handle))
	@SearchAfter.setter
	def SearchAfter(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_SearchAfter_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SearchBefore(self):
		return go.Slice_string(handle=_bleve.bleve_SearchRequest_SearchBefore_Get(self.handle))
	@SearchBefore.setter
	def SearchBefore(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchRequest_SearchBefore_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Validate(self):
		"""Validate() str"""
		return _bleve.bleve_SearchRequest_Validate(self.handle)
	def AddFacet(self, facetName, f, goRun=False):
		"""AddFacet(str facetName, object f) 
		
		AddFacet adds a FacetRequest to this SearchRequest
		"""
		_bleve.bleve_SearchRequest_AddFacet(self.handle, facetName, f.handle, goRun)
	def SortBy(self, order, goRun=False):
		"""SortBy([]str order) 
		
		SortBy changes the request to use the requested sort order
		this form uses the simplified syntax with an array of strings
		each string can either be a field name
		or the magic value _id and _score which refer to the doc id and search score
		any of these values can optionally be prefixed with - to reverse the order
		"""
		_bleve.bleve_SearchRequest_SortBy(self.handle, order.handle, goRun)
	def SortByCustom(self, order, goRun=False):
		"""SortByCustom([]object order) 
		
		SortByCustom changes the request to use the requested sort order
		"""
		_bleve.bleve_SearchRequest_SortByCustom(self.handle, order.handle, goRun)
	def SetSearchAfter(self, after, goRun=False):
		"""SetSearchAfter([]str after) 
		
		SetSearchAfter sets the request to skip over hits with a sort
		value less than the provided sort after key
		"""
		_bleve.bleve_SearchRequest_SetSearchAfter(self.handle, after.handle, goRun)
	def SetSearchBefore(self, before, goRun=False):
		"""SetSearchBefore([]str before) 
		
		SetSearchBefore sets the request to skip over hits with a sort
		value greater than the provided sort before key
		"""
		_bleve.bleve_SearchRequest_SetSearchBefore(self.handle, before.handle, goRun)
	def UnmarshalJSON(self, input):
		"""UnmarshalJSON([]int input) str
		
		UnmarshalJSON deserializes a JSON representation of
		a SearchRequest
		"""
		return _bleve.bleve_SearchRequest_UnmarshalJSON(self.handle, input.handle)
	def SetSortFunc(self, s, goRun=False):
		"""SetSortFunc(callable s) 
		
		SetSortFunc sets the sort implementation to use when sorting hits.
		
		SearchRequests can specify a custom sort implementation to meet
		their needs. For instance, by specifying a parallel sort
		that uses all available cores.
		"""
		_bleve.bleve_SearchRequest_SetSortFunc(self.handle, s, goRun)

# Python type for struct bleve.SearchResult
class SearchResult(go.GoClass):
	"""A SearchResult describes the results of executing\na SearchRequest.\n\nStatus - Whether the search was executed on the underlying indexes successfully\nor failed, and the corresponding errors.\nRequest - The SearchRequest that was executed.\nHits - The list of documents that matched the query and their corresponding\nscores, score explanation, location info and so on.\nTotal - The total number of documents that matched the query.\nCost - indicates how expensive was the query with respect to bytes read\nfrom the mmaped index files.\nMaxScore - The maximum score seen across all document hits seen for this query.\nTook - The time taken to execute the search.\nFacets - The facet results for the search.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_SearchResult_CTor()
			_bleve.IncRef(self.handle)
			if  0 < len(args):
				self.Status = args[0]
			if "Status" in kwargs:
				self.Status = kwargs["Status"]
			if  1 < len(args):
				self.Request = args[1]
			if "Request" in kwargs:
				self.Request = kwargs["Request"]
			if  2 < len(args):
				self.Hits = args[2]
			if "Hits" in kwargs:
				self.Hits = kwargs["Hits"]
			if  3 < len(args):
				self.Total = args[3]
			if "Total" in kwargs:
				self.Total = kwargs["Total"]
			if  4 < len(args):
				self.Cost = args[4]
			if "Cost" in kwargs:
				self.Cost = kwargs["Cost"]
			if  5 < len(args):
				self.MaxScore = args[5]
			if "MaxScore" in kwargs:
				self.MaxScore = kwargs["MaxScore"]
			if  6 < len(args):
				self.Took = args[6]
			if "Took" in kwargs:
				self.Took = kwargs["Took"]
			if  7 < len(args):
				self.Facets = args[7]
			if "Facets" in kwargs:
				self.Facets = kwargs["Facets"]
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.SearchResult ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Status(self):
		return SearchStatus(handle=_bleve.bleve_SearchResult_Status_Get(self.handle))
	@Status.setter
	def Status(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchResult_Status_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Request(self):
		return SearchRequest(handle=_bleve.bleve_SearchResult_Request_Get(self.handle))
	@Request.setter
	def Request(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchResult_Request_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Hits(self):
		return go.search_DocumentMatchCollection(handle=_bleve.bleve_SearchResult_Hits_Get(self.handle))
	@Hits.setter
	def Hits(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchResult_Hits_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Total(self):
		return _bleve.bleve_SearchResult_Total_Get(self.handle)
	@Total.setter
	def Total(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchResult_Total_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchResult_Total_Set(self.handle, value)
	@property
	def Cost(self):
		return _bleve.bleve_SearchResult_Cost_Get(self.handle)
	@Cost.setter
	def Cost(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchResult_Cost_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchResult_Cost_Set(self.handle, value)
	@property
	def MaxScore(self):
		return _bleve.bleve_SearchResult_MaxScore_Get(self.handle)
	@MaxScore.setter
	def MaxScore(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchResult_MaxScore_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchResult_MaxScore_Set(self.handle, value)
	@property
	def Took(self):
		return _bleve.bleve_SearchResult_Took_Get(self.handle)
	@Took.setter
	def Took(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchResult_Took_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchResult_Took_Set(self.handle, value)
	@property
	def Facets(self):
		return go.search_FacetResults(handle=_bleve.bleve_SearchResult_Facets_Get(self.handle))
	@Facets.setter
	def Facets(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchResult_Facets_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Size(self):
		"""Size() int"""
		return _bleve.bleve_SearchResult_Size(self.handle)
	def String(self):
		"""String() str"""
		return _bleve.bleve_SearchResult_String(self.handle)
	def Merge(self, other, goRun=False):
		"""Merge(object other) 
		
		Merge will merge together multiple SearchResults during a MultiSearch
		"""
		_bleve.bleve_SearchResult_Merge(self.handle, other.handle, goRun)

# Python type for struct bleve.SearchStatus
class SearchStatus(go.GoClass):
	"""SearchStatus is a secion in the SearchResult reporting how many\nunderlying indexes were queried, how many were successful/failed\nand a map of any errors that were encountered\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_SearchStatus_CTor()
			_bleve.IncRef(self.handle)
			if  0 < len(args):
				self.Total = args[0]
			if "Total" in kwargs:
				self.Total = kwargs["Total"]
			if  1 < len(args):
				self.Failed = args[1]
			if "Failed" in kwargs:
				self.Failed = kwargs["Failed"]
			if  2 < len(args):
				self.Successful = args[2]
			if "Successful" in kwargs:
				self.Successful = kwargs["Successful"]
			if  3 < len(args):
				self.Errors = args[3]
			if "Errors" in kwargs:
				self.Errors = kwargs["Errors"]
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.SearchStatus{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.SearchStatus ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Total(self):
		return _bleve.bleve_SearchStatus_Total_Get(self.handle)
	@Total.setter
	def Total(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchStatus_Total_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchStatus_Total_Set(self.handle, value)
	@property
	def Failed(self):
		return _bleve.bleve_SearchStatus_Failed_Get(self.handle)
	@Failed.setter
	def Failed(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchStatus_Failed_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchStatus_Failed_Set(self.handle, value)
	@property
	def Successful(self):
		return _bleve.bleve_SearchStatus_Successful_Get(self.handle)
	@Successful.setter
	def Successful(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchStatus_Successful_Set(self.handle, value.handle)
		else:
			_bleve.bleve_SearchStatus_Successful_Set(self.handle, value)
	@property
	def Errors(self):
		return IndexErrMap(handle=_bleve.bleve_SearchStatus_Errors_Get(self.handle))
	@Errors.setter
	def Errors(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_SearchStatus_Errors_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Merge(self, other, goRun=False):
		"""Merge(object other) 
		
		Merge will merge together multiple SearchStatuses during a MultiSearch
		"""
		_bleve.bleve_SearchStatus_Merge(self.handle, other.handle, goRun)

# Python type for struct bleve.Batch
class Batch(go.GoClass):
	"""A Batch groups together multiple Index and Delete\noperations you would like performed at the same\ntime.  The Batch structure is NOT thread-safe.\nYou should only perform operations on a batch\nfrom a single thread at a time.  Once batch\nexecution has started, you may not modify it.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_Batch_CTor()
			_bleve.IncRef(self.handle)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.Batch ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Index(self, id, data):
		"""Index(str id, str data) str
		
		Index adds the specified index operation to the
		batch.  NOTE: the bleve Index is not updated
		until the batch is executed.
		"""
		return _bleve.bleve_Batch_Index(self.handle, id, data)
	def LastDocSize(self):
		"""LastDocSize() long"""
		return _bleve.bleve_Batch_LastDocSize(self.handle)
	def TotalDocsSize(self):
		"""TotalDocsSize() long"""
		return _bleve.bleve_Batch_TotalDocsSize(self.handle)
	def IndexAdvanced(self, doc):
		"""IndexAdvanced(object doc) str err
		
		IndexAdvanced adds the specified index operation to the
		batch which skips the mapping.  NOTE: the bleve Index is not updated
		until the batch is executed.
		"""
		return _bleve.bleve_Batch_IndexAdvanced(self.handle, doc.handle)
	def Delete(self, id, goRun=False):
		"""Delete(str id) 
		
		Delete adds the specified delete operation to the
		batch.  NOTE: the bleve Index is not updated until
		the batch is executed.
		"""
		_bleve.bleve_Batch_Delete(self.handle, id, goRun)
	def SetInternal(self, key, val, goRun=False):
		"""SetInternal([]int key, []int val) 
		
		SetInternal adds the specified set internal
		operation to the batch. NOTE: the bleve Index is
		not updated until the batch is executed.
		"""
		_bleve.bleve_Batch_SetInternal(self.handle, key.handle, val.handle, goRun)
	def DeleteInternal(self, key, goRun=False):
		"""DeleteInternal([]int key) 
		
		DeleteInternal adds the specified delete internal
		operation to the batch. NOTE: the bleve Index is
		not updated until the batch is executed.
		"""
		_bleve.bleve_Batch_DeleteInternal(self.handle, key.handle, goRun)
	def Size(self):
		"""Size() int
		
		Size returns the total number of operations inside the batch
		including normal index operations and internal operations.
		"""
		return _bleve.bleve_Batch_Size(self.handle)
	def String(self):
		"""String() str
		
		String prints a user friendly string representation of what
		is inside this batch.
		"""
		return _bleve.bleve_Batch_String(self.handle)
	def Reset(self, goRun=False):
		"""Reset() 
		
		Reset returns a Batch to the empty state so that it can
		be re-used in the future.
		"""
		_bleve.bleve_Batch_Reset(self.handle, goRun)
	def Merge(self, o, goRun=False):
		"""Merge(object o) """
		_bleve.bleve_Batch_Merge(self.handle, o.handle, goRun)

# Python type for struct bleve.FacetRequest
class FacetRequest(go.GoClass):
	"""A FacetRequest describes a facet or aggregation\nof the result document set you would like to be\nbuilt.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_FacetRequest_CTor()
			_bleve.IncRef(self.handle)
			if  0 < len(args):
				self.Size = args[0]
			if "Size" in kwargs:
				self.Size = kwargs["Size"]
			if  1 < len(args):
				self.Field = args[1]
			if "Field" in kwargs:
				self.Field = kwargs["Field"]
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.FacetRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.FacetRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Size(self):
		return _bleve.bleve_FacetRequest_Size_Get(self.handle)
	@Size.setter
	def Size(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_FacetRequest_Size_Set(self.handle, value.handle)
		else:
			_bleve.bleve_FacetRequest_Size_Set(self.handle, value)
	@property
	def Field(self):
		return _bleve.bleve_FacetRequest_Field_Get(self.handle)
	@Field.setter
	def Field(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_FacetRequest_Field_Set(self.handle, value.handle)
		else:
			_bleve.bleve_FacetRequest_Field_Set(self.handle, value)
	def Validate(self):
		"""Validate() str"""
		return _bleve.bleve_FacetRequest_Validate(self.handle)
	def AddDateTimeRange(self, name, start, end, goRun=False):
		"""AddDateTimeRange(str name, object start, object end) 
		
		AddDateTimeRange adds a bucket to a field
		containing date values.  Documents with a
		date value falling into this range are tabulated
		as part of this bucket/range.
		"""
		_bleve.bleve_FacetRequest_AddDateTimeRange(self.handle, name, start.handle, end.handle, goRun)

# Python type for struct bleve.HighlightRequest
class HighlightRequest(go.GoClass):
	"""HighlightRequest describes how field matches\nshould be highlighted.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_HighlightRequest_CTor()
			_bleve.IncRef(self.handle)
			if  1 < len(args):
				self.Fields = args[1]
			if "Fields" in kwargs:
				self.Fields = kwargs["Fields"]
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.HighlightRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.HighlightRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Fields(self):
		return go.Slice_string(handle=_bleve.bleve_HighlightRequest_Fields_Get(self.handle))
	@Fields.setter
	def Fields(self, value):
		if isinstance(value, go.GoClass):
			_bleve.bleve_HighlightRequest_Fields_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def AddField(self, field, goRun=False):
		"""AddField(str field) """
		_bleve.bleve_HighlightRequest_AddField(self.handle, field, goRun)

# Python type for struct bleve.IndexStat
class IndexStat(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_IndexStat_CTor()
			_bleve.IncRef(self.handle)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.IndexStat{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.IndexStat ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def MarshalJSON(self):
		"""MarshalJSON() []int, str"""
		return go.Slice_byte(handle=_bleve.bleve_IndexStat_MarshalJSON(self.handle))

# Python type for struct bleve.IndexStats
class IndexStats(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_IndexStats_CTor()
			_bleve.IncRef(self.handle)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'bleve.IndexStats ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Register(self, index, goRun=False):
		"""Register(object index) """
		_bleve.bleve_IndexStats_Register(self.handle, index.handle, goRun)
	def UnRegister(self, index, goRun=False):
		"""UnRegister(object index) """
		_bleve.bleve_IndexStats_UnRegister(self.handle, index.handle, goRun)
	def String(self):
		"""String() str"""
		return _bleve.bleve_IndexStats_String(self.handle)


# ---- Slices ---


# ---- Maps ---

# Python type for map bleve.FacetsRequest
class FacetsRequest(go.GoClass):
	"""FacetsRequest groups together all the\nFacetRequest objects for a single query.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_FacetsRequest_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('bleve_FacetsRequest.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bleve.bleve_FacetsRequest_set(self.handle, k, v)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.bleve_FacetsRequest len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bleve.bleve_FacetsRequest({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bleve.bleve_FacetsRequest_len(self.handle)
	def __getitem__(self, key):
		return FacetRequest(handle=_bleve.bleve_FacetsRequest_elem(self.handle, key))
	def __setitem__(self, key, value):
		_bleve.bleve_FacetsRequest_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _bleve.bleve_FacetsRequest_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_bleve.bleve_FacetsRequest_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bleve.bleve_FacetsRequest_contains(self.handle, key)
	def Validate(self):
		"""Validate() str"""
		return _bleve.bleve_FacetsRequest_Validate(self.handle)

# Python type for map bleve.IndexErrMap
class IndexErrMap(go.GoClass):
	"""IndexErrMap tracks errors with the name of the index where it occurred\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bleve.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bleve.IncRef(self.handle)
		else:
			self.handle = _bleve.bleve_IndexErrMap_CTor()
			_bleve.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('bleve_IndexErrMap.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bleve.bleve_IndexErrMap_set(self.handle, k, v)
	def __del__(self):
		_bleve.DecRef(self.handle)
	def __str__(self):
		s = 'bleve.bleve_IndexErrMap len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bleve.bleve_IndexErrMap({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bleve.bleve_IndexErrMap_len(self.handle)
	def __getitem__(self, key):
		return _bleve.bleve_IndexErrMap_elem(self.handle, key)
	def __setitem__(self, key, value):
		_bleve.bleve_IndexErrMap_set(self.handle, key, value)
	def __delitem__(self, key):
		return _bleve.bleve_IndexErrMap_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_bleve.bleve_IndexErrMap_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bleve.bleve_IndexErrMap_contains(self.handle, key)
	def MarshalJSON(self):
		"""MarshalJSON() []int, str
		
		MarshalJSON seralizes the error into a string for JSON consumption
		"""
		return go.Slice_byte(handle=_bleve.bleve_IndexErrMap_MarshalJSON(self.handle))
	def UnmarshalJSON(self, data):
		"""UnmarshalJSON([]int data) str"""
		return _bleve.bleve_IndexErrMap_UnmarshalJSON(self.handle, data.handle)


# ---- Constructors ---
def NewSearchRequestOptions(q, size, myfrom, explain):
	"""NewSearchRequestOptions(object q, int size, int from, bool explain) object
	
	NewSearchRequestOptions creates a new SearchRequest
	for the Query, with the requested size, from
	and explanation search parameters.
	By default results are ordered by score, descending.
	"""
	return SearchRequest(handle=_bleve.bleve_NewSearchRequestOptions(q.handle, size, myfrom, explain))
def NewSearchRequest(q):
	"""NewSearchRequest(object q) object
	
	NewSearchRequest creates a new SearchRequest
	for the Query, using default values for all
	other search parameters.
	"""
	return SearchRequest(handle=_bleve.bleve_NewSearchRequest(q.handle))
def MultiSearch(ctx, req, *args):
	"""MultiSearch(object ctx, object req, []object indexes) object, str
	
	MultiSearch executes a SearchRequest across multiple Index objects,
	then merges the results.  The indexes must honor any ctx deadline.
	"""
	indexes = Slice_bleve_Index(args)
	return SearchResult(handle=_bleve.bleve_MultiSearch(ctx.handle, req.handle, indexes.handle))
def NewFacetRequest(field, size):
	"""NewFacetRequest(str field, int size) object
	
	NewFacetRequest creates a facet on the specified
	field that limits the number of entries to the
	specified size.
	"""
	return FacetRequest(handle=_bleve.bleve_NewFacetRequest(field, size))
def NewHighlightWithStyle(style):
	"""NewHighlightWithStyle(str style) object
	
	NewHighlightWithStyle creates a HighlightRequest
	with an alternate style.
	"""
	return HighlightRequest(handle=_bleve.bleve_NewHighlightWithStyle(style))
def NewHighlight():
	"""NewHighlight() object
	
	NewHighlight creates a default
	HighlightRequest.
	"""
	return HighlightRequest(handle=_bleve.bleve_NewHighlight())
def NewIndexStats():
	"""NewIndexStats() object"""
	return IndexStats(handle=_bleve.bleve_NewIndexStats())


# ---- Functions ---
def NewMatchQuery(match):
	"""NewMatchQuery(str match) object
	
	NewMatchQuery creates a Query for matching text.
	An Analyzer is chosen based on the field.
	Input text is analyzed using this analyzer.
	Token terms resulting from this analysis are
	used to perform term searches.  Result documents
	must satisfy at least one of these term searches.
	"""
	return go.Ptr_query_MatchQuery(handle=_bleve.bleve_NewMatchQuery(match))
def NewDocumentDisabledMapping():
	"""NewDocumentDisabledMapping() object
	
	NewDocumentDisabledMapping returns a new document
	mapping that will not perform any indexing.
	"""
	return go.Ptr_mapping_DocumentMapping(handle=_bleve.bleve_NewDocumentDisabledMapping())
def NewDocumentMapping():
	"""NewDocumentMapping() object
	
	NewDocumentMapping returns a new document mapping
	with all the default values.
	"""
	return go.Ptr_mapping_DocumentMapping(handle=_bleve.bleve_NewDocumentMapping())
def NewIPFieldMapping():
	"""NewIPFieldMapping() object"""
	return go.Ptr_mapping_FieldMapping(handle=_bleve.bleve_NewIPFieldMapping())
def NewMatchAllQuery():
	"""NewMatchAllQuery() object
	
	NewMatchAllQuery creates a Query which will
	match all documents in the index.
	"""
	return go.Ptr_query_MatchAllQuery(handle=_bleve.bleve_NewMatchAllQuery())
def NewIndexMapping():
	"""NewIndexMapping() object
	
	NewIndexMapping creates a new IndexMapping that will use all the default indexing rules
	"""
	return go.Ptr_mapping_IndexMappingImpl(handle=_bleve.bleve_NewIndexMapping())
def NewMatchPhraseQuery(matchPhrase):
	"""NewMatchPhraseQuery(str matchPhrase) object
	
	NewMatchPhraseQuery creates a new Query object
	for matching phrases in the index.
	An Analyzer is chosen based on the field.
	Input text is analyzed using this analyzer.
	Token terms resulting from this analysis are
	used to build a search phrase.  Result documents
	must match this phrase. Queried field must have been indexed with
	IncludeTermVectors set to true.
	"""
	return go.Ptr_query_MatchPhraseQuery(handle=_bleve.bleve_NewMatchPhraseQuery(matchPhrase))
def NewRegexpQuery(regexp):
	"""NewRegexpQuery(str regexp) object
	
	NewRegexpQuery creates a new Query which finds
	documents containing terms that match the
	specified regular expression.
	"""
	return go.Ptr_query_RegexpQuery(handle=_bleve.bleve_NewRegexpQuery(regexp))
def NewBoolFieldQuery(val):
	"""NewBoolFieldQuery(bool val) object
	
	NewBoolFieldQuery creates a new Query for boolean fields
	"""
	return go.Ptr_query_BoolFieldQuery(handle=_bleve.bleve_NewBoolFieldQuery(val))
def NewFuzzyQuery(term):
	"""NewFuzzyQuery(str term) object
	
	NewFuzzyQuery creates a new Query which finds
	documents containing terms within a specific
	fuzziness of the specified term.
	The default fuzziness is 1.
	
	The current implementation uses Levenshtein edit
	distance as the fuzziness metric.
	"""
	return go.Ptr_query_FuzzyQuery(handle=_bleve.bleve_NewFuzzyQuery(term))
def NewGeoPointFieldMapping():
	"""NewGeoPointFieldMapping() object"""
	return go.Ptr_mapping_FieldMapping(handle=_bleve.bleve_NewGeoPointFieldMapping())
def NewMatchNoneQuery():
	"""NewMatchNoneQuery() object
	
	NewMatchNoneQuery creates a Query which will not
	match any documents in the index.
	"""
	return go.Ptr_query_MatchNoneQuery(handle=_bleve.bleve_NewMatchNoneQuery())
def NewPhraseQuery(terms, field):
	"""NewPhraseQuery([]str terms, str field) object
	
	NewPhraseQuery creates a new Query for finding
	exact term phrases in the index.
	The provided terms must exist in the correct
	order, at the correct index offsets, in the
	specified field. Queried field must have been indexed with
	IncludeTermVectors set to true.
	"""
	return go.Ptr_query_PhraseQuery(handle=_bleve.bleve_NewPhraseQuery(terms.handle, field))
def Open(path):
	"""Open(str path) object, str"""
	return Index(handle=_bleve.bleve_Open(path))
def NewGeoBoundingBoxQuery(topLeftLon, topLeftLat, bottomRightLon, bottomRightLat):
	"""NewGeoBoundingBoxQuery(float topLeftLon, float topLeftLat, float bottomRightLon, float bottomRightLat) object
	
	NewGeoBoundingBoxQuery creates a new Query for performing geo bounding
	box searches. The arguments describe the position of the box and documents
	which have an indexed geo point inside the box will be returned.
	"""
	return go.Ptr_query_GeoBoundingBoxQuery(handle=_bleve.bleve_NewGeoBoundingBoxQuery(topLeftLon, topLeftLat, bottomRightLon, bottomRightLat))
def NewGeoShapeCircleQuery(coordinates, radius, relation):
	"""NewGeoShapeCircleQuery([]float coordinates, str radius, str relation) object, str
	
	NewGeoShapeCircleQuery creates a new query for a geoshape that is a
	circle given center point and the radius. Radius formats supported:
	"5in" "5inch" "7yd" "7yards" "9ft" "9feet" "11km" "11kilometers"
	"3nm" "3nauticalmiles" "13mm" "13millimeters" "15cm" "15centimeters"
	"17mi" "17miles" "19m" "19meters" If the unit cannot be determined,
	the entire string is parsed and the unit of meters is assumed.
	"""
	return go.Ptr_query_GeoShapeQuery(handle=_bleve.bleve_NewGeoShapeCircleQuery(coordinates.handle, radius, relation))
def NewGeoShapeQuery(coordinates, typ, relation):
	"""NewGeoShapeQuery([][][][]float coordinates, str typ, str relation) object, str
	
	NewGeoShapeQuery creates a new Query for matching the given geo shape.
	This method can be used for creating geoshape queries for shape types
	like: point, linestring, polygon, multipoint, multilinestring,
	multipolygon and envelope.
	"""
	return go.Ptr_query_GeoShapeQuery(handle=_bleve.bleve_NewGeoShapeQuery(coordinates.handle, typ, relation))
def OpenUsing(path, runtimeConfig):
	"""OpenUsing(str path, object runtimeConfig) object, str"""
	return Index(handle=_bleve.bleve_OpenUsing(path, runtimeConfig.handle))
def NewQueryStringQuery(q):
	"""NewQueryStringQuery(str q) object
	
	NewQueryStringQuery creates a new Query used for
	finding documents that satisfy a query string.  The
	query string is a small query language for humans.
	"""
	return go.Ptr_query_QueryStringQuery(handle=_bleve.bleve_NewQueryStringQuery(q))
def NewTermQuery(term):
	"""NewTermQuery(str term) object
	
	NewTermQuery creates a new Query for finding an
	exact term match in the index.
	"""
	return go.Ptr_query_TermQuery(handle=_bleve.bleve_NewTermQuery(term))
def NewDateTimeFieldMapping():
	"""NewDateTimeFieldMapping() object
	
	NewDateTimeFieldMapping returns a default field mapping for dates
	"""
	return go.Ptr_mapping_FieldMapping(handle=_bleve.bleve_NewDateTimeFieldMapping())
def NewDocIDQuery(ids):
	"""NewDocIDQuery([]str ids) object
	
	NewDocIDQuery creates a new Query object returning indexed documents among
	the specified set. Combine it with ConjunctionQuery to restrict the scope of
	other queries output.
	"""
	return go.Ptr_query_DocIDQuery(handle=_bleve.bleve_NewDocIDQuery(ids.handle))
def NewGeoDistanceQuery(lon, lat, distance):
	"""NewGeoDistanceQuery(float lon, float lat, str distance) object
	
	NewGeoDistanceQuery creates a new Query for performing geo distance
	searches. The arguments describe a position and a distance. Documents
	which have an indexed geo point which is less than or equal to the provided
	distance from the given position will be returned.
	"""
	return go.Ptr_query_GeoDistanceQuery(handle=_bleve.bleve_NewGeoDistanceQuery(lon, lat, distance))
def NewIPRangeQuery(cidr):
	"""NewIPRangeQuery(str cidr) object
	
	NewIPRangeQuery creates a new Query for matching IP addresses.
	If the argument is in CIDR format, then the query will match all
	IP addresses in the network specified. If the argument is an IP address,
	then the query will return documents which contain that IP.
	Both ipv4 and ipv6 are supported.
	"""
	return go.Ptr_query_IPRangeQuery(handle=_bleve.bleve_NewIPRangeQuery(cidr))
def NewNumericFieldMapping():
	"""NewNumericFieldMapping() object
	
	NewNumericFieldMapping returns a default field mapping for numbers
	"""
	return go.Ptr_mapping_FieldMapping(handle=_bleve.bleve_NewNumericFieldMapping())
def NewPrefixQuery(prefix):
	"""NewPrefixQuery(str prefix) object
	
	NewPrefixQuery creates a new Query which finds
	documents containing terms that start with the
	specified prefix.
	"""
	return go.Ptr_query_PrefixQuery(handle=_bleve.bleve_NewPrefixQuery(prefix))
def SetLog(l, goRun=False):
	"""SetLog(object l) 
	
	SetLog sets the logger used for logging
	by default log messages are sent to ioutil.Discard
	"""
	_bleve.bleve_SetLog(l.handle, goRun)
def MemoryNeededForSearchResult(req):
	"""MemoryNeededForSearchResult(object req) long
	
	MemoryNeededForSearchResult is an exported helper function to determine the RAM
	needed to accommodate the results for a given search request.
	"""
	return _bleve.bleve_MemoryNeededForSearchResult(req.handle)
def NewBooleanQuery():
	"""NewBooleanQuery() object
	
	NewBooleanQuery creates a compound Query composed
	of several other Query objects.
	These other query objects are added using the
	AddMust() AddShould() and AddMustNot() methods.
	Result documents must satisfy ALL of the
	must Queries.
	Result documents must satisfy NONE of the must not
	Queries.
	Result documents that ALSO satisfy any of the should
	Queries will score higher.
	"""
	return go.Ptr_query_BooleanQuery(handle=_bleve.bleve_NewBooleanQuery())
def NewGeoShapeFieldMapping():
	"""NewGeoShapeFieldMapping() object"""
	return go.Ptr_mapping_FieldMapping(handle=_bleve.bleve_NewGeoShapeFieldMapping())
def NewTextFieldMapping():
	"""NewTextFieldMapping() object
	
	NewTextFieldMapping returns a default field mapping for text
	"""
	return go.Ptr_mapping_FieldMapping(handle=_bleve.bleve_NewTextFieldMapping())
def NewMemOnly(mapping):
	"""NewMemOnly(object mapping) object, str"""
	return Index(handle=_bleve.bleve_NewMemOnly(mapping.handle))
def NewTermRangeQuery(min, max):
	"""NewTermRangeQuery(str min, str max) object
	
	NewTermRangeQuery creates a new Query for ranges
	of text terms.
	Either, but not both endpoints can be "".
	The minimum value is inclusive.
	The maximum value is exclusive.
	"""
	return go.Ptr_query_TermRangeQuery(handle=_bleve.bleve_NewTermRangeQuery(min, max))
def New(path, mapping):
	"""New(str path, object mapping) object, str"""
	return Index(handle=_bleve.bleve_New(path, mapping.handle))
def NewConjunctionQuery(*args):
	"""NewConjunctionQuery([]object conjuncts) object
	
	NewConjunctionQuery creates a new compound Query.
	Result documents must satisfy all of the queries.
	"""
	conjuncts = Slice_query_Query(args)
	return go.Ptr_query_ConjunctionQuery(handle=_bleve.bleve_NewConjunctionQuery(conjuncts.handle))
def NewDateRangeQuery(start, end):
	"""NewDateRangeQuery(object start, object end) object
	
	NewDateRangeQuery creates a new Query for ranges
	of date values.
	Date strings are parsed using the DateTimeParser configured in the
	 top-level config.QueryDateTimeParser
	Either, but not both endpoints can be nil.
	"""
	return go.Ptr_query_DateRangeQuery(handle=_bleve.bleve_NewDateRangeQuery(start.handle, end.handle))
def NewDocumentStaticMapping():
	"""NewDocumentStaticMapping() object
	
	NewDocumentStaticMapping returns a new document
	mapping that will not automatically index parts
	of a document without an explicit mapping.
	"""
	return go.Ptr_mapping_DocumentMapping(handle=_bleve.bleve_NewDocumentStaticMapping())
def NewKeywordFieldMapping():
	"""NewKeywordFieldMapping() object
	
	NewKeywordFieldMapping returns a field mapping for text using the keyword
	analyzer, which essentially doesn't apply any specific text analysis.
	"""
	return go.Ptr_mapping_FieldMapping(handle=_bleve.bleve_NewKeywordFieldMapping())
def NewUsing(path, mapping, indexType, kvstore, kvconfig):
	"""NewUsing(str path, object mapping, str indexType, str kvstore, object kvconfig) object, str"""
	return Index(handle=_bleve.bleve_NewUsing(path, mapping.handle, indexType, kvstore, kvconfig.handle))
def NewWildcardQuery(wildcard):
	"""NewWildcardQuery(str wildcard) object
	
	NewWildcardQuery creates a new Query which finds
	documents containing terms that match the
	specified wildcard.  In the wildcard pattern '*'
	will match any sequence of 0 or more characters,
	and '?' will match any single character.
	"""
	return go.Ptr_query_WildcardQuery(handle=_bleve.bleve_NewWildcardQuery(wildcard))
def NewBooleanFieldMapping():
	"""NewBooleanFieldMapping() object
	
	NewBooleanFieldMapping returns a default field mapping for booleans
	"""
	return go.Ptr_mapping_FieldMapping(handle=_bleve.bleve_NewBooleanFieldMapping())
def NewBuilder(path, mapping, config):
	"""NewBuilder(str path, object mapping, object config) object, str"""
	return Builder(handle=_bleve.bleve_NewBuilder(path, mapping.handle, config.handle))
def NewDisjunctionQuery(*args):
	"""NewDisjunctionQuery([]object disjuncts) object
	
	NewDisjunctionQuery creates a new compound Query.
	Result documents satisfy at least one Query.
	"""
	disjuncts = Slice_query_Query(args)
	return go.Ptr_query_DisjunctionQuery(handle=_bleve.bleve_NewDisjunctionQuery(disjuncts.handle))
def NewGeometryCollectionQuery(coordinates, types, relation):
	"""NewGeometryCollectionQuery([][][][][]float coordinates, []str types, str relation) object, str
	
	NewGeometryCollectionQuery creates a new query for the provided
	geometrycollection coordinates and types, which could contain
	multiple geo shapes.
	"""
	return go.Ptr_query_GeoShapeQuery(handle=_bleve.bleve_NewGeometryCollectionQuery(coordinates.handle, types.handle, relation))


